/**

* 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
*
*
*
* 示例 1：
*
* 输入：00000000000000000000000000001011
* 输出：3
* 解释：输入的二进制串 00000000000000000000000000001011中，共有三位为 '1'。
* 示例 2：
*
* 输入：00000000000000000000000010000000
* 输出：1
* 解释：输入的二进制串 00000000000000000000000010000000中，共有一位为 '1'。
* 示例 3：
*
* 输入：11111111111111111111111111111101
* 输出：31
* 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
*
* 提示：
*
* 输入必须是长度为 32 的 二进制串 。
*
* 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/
*
* 通过次数115,249提交次数157,629
*
* 来源：力扣（LeetCode）
* 链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof
* 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
  */

````java
/**
 * 方法一：逐位判断
 根据 与运算 定义，设二进制数字 nn ，则有：
 若 n \& 1 = 0n&1=0 ，则 nn 二进制 最右一位 为 00 ；
 若 n \& 1 = 1n&1=1 ，则 nn 二进制 最右一位 为 11 。
 根据以上特点，考虑以下 循环判断 ：
 判断 nn 最右一位是否为 11 ，根据结果计数。
 将 nn 右移一位（本题要求把数字 nn 看作无符号数，因此使用 无符号右移 操作）。
 算法流程：
 初始化数量统计变量 res = 0res=0 。
 循环逐位判断： 当 n = 0n=0 时跳出。
 res += n & 1 ： 若 n \& 1 = 1n&1=1 ，则统计数 resres 加一。
 n >>= 1 ： 将二进制数字 nn 无符号右移一位（ Java 中无符号右移为 ">>>>>>" ） 。
 返回统计数量 resres 。
 */
public class Solution {
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            res += n & 1;
            n >>>= 1;
        }
        return res;
    }
}
````

